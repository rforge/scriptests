\documentclass{article}
\title{Creating a simple R package and unit tests with the scriptests package}
\author{Tony Plate}
\begin{document}
\maketitle

\section{Introduction}

Scriptests uses text files containing R commands and output, as
though copied verbatim from an interactive R session.  The output in the
transcript file must match the actual output from running the command
for the test to pass (with some exceptions - see "Control over matching"
below).  This is the same concept as the standard
\texttt{.R/.Rout.save} tests that are run by the \texttt{R CMD check}, but
with some enhancements that are intended to make test development and
maintanance faster, more convenient, and easier to automate:
\begin{itemize}
  \item Only the output file is needed - the inputs are parsed from
  the output file (i.e., \texttt{.Rt} file, which is analogous to an
  \texttt{.Rout.save} file)
  \item Test output matching is more lenient on white space differences,
  and more flexible in that some test output can be transformed by
  regular expressions prior to matching, or ignored entirely
  \item directives can specify whether a test-case output mismatch
  should be noted as an informational message, a warning, or an error
  (one or more errors results in \texttt{R CMD check} stopping with an
  indication of error after running all tests).  Unlike the standard
  tests in \texttt{R CMD check}, output mismatch detected by
  \texttt{scriptests} results in \texttt{R CMD check} stopping with an error.
  \item A concise summary of warnings and errors is given at the end
  \item Testing can continue after errors and can report multiple errors
  at the end, rather than stopping at the first error.
\end{itemize}

\section{Creating a simple package}

Create a complete R package named \texttt{testpkg} containing 4 files:
\begin{itemize}
  \item testpkg/DESCRIPTION
  \item testpkg/R/plus.R
  \item testpkg/tests/runtests.R
  \item testpkg/tests/plus.Rt
\end{itemize}
\SweaveOpts{keep.source=TRUE}
<<echo=FALSE>>=
Sys.setenv("R_NOUSERPROFILE"=1)
@
<<>>=
# This R code creates a simple package containing 4 files
dir.create("testpkg")
cat(                                 file="testpkg/DESCRIPTION", '
Package: testpkg
Version: 1.0-0
License: GPL-3
Description: A simple example of using scriptests for unit tests
Title: Unit tests with scriptests
Author: Joe Blow <joeblo@foobar.org>
Maintainer: Joe Blow <joeblo@foobar.org>
Suggests: scriptests
')

dir.create("testpkg/R")
cat(                                 file="testpkg/R/plus.R", '
plus <- function(x, y) x + y
')

dir.create("testpkg/man")
cat(                                 file="testpkg/man/plus.Rd", '
\\name{plus}
\\alias{plus}
\\title{Add two numbers together}
\\description{Add two numbers together}
\\usage{plus(x, y)}
\\arguments{
  \\item{x}{A number}
  \\item{y}{A number}
}
\\value{A number}
')
@

\section{Adding some tests to the package}

<<>>=
dir.create("testpkg/tests")
cat(                                 file="testpkg/tests/runtests.R", '
library(scriptests)
runScripTests()
')

cat(                                 file="testpkg/tests/plus.Rt", '
> plus(3, 4)
[1] 7
')
@

\section{Running the tests interactively}

This is often a good way of running tests while developing
code.  Tests are run in the current R session and can
create, modify or delete variables in the R session.  This
is convenient and fast, partly because it doesn't fully
build the pacakge -- it just loads the R source files from
the package into the R session.  (Actually,
\texttt{source.pkg()} can do a bit more than that, but it
doesn't understand namespaces, so if the package being
loaded depends on namespaces, it won't work.)

<<>>=
source.pkg(pkg="testpkg")
runtests(pkg="testpkg", pattern="plus", clobber=T)
@


\section{Running the tests as part of ``R CMD check''}

<<>>=
system2 <- function(cmd) cat(system(cmd, intern=TRUE), sep="\n")
system2("R CMD build testpkg")
system2("R CMD check testpkg_1.0-0.tar.gz")
cat(readLines("testpkg.Rcheck/tests/plus.Rt.log"), sep="\n")
cat(readLines("testpkg.Rcheck/tests/test-summary.txt"), sep="\n")
@

\section{Stuff to rearrange}

add the line \texttt{Suggests: scriptests} to DESCRIPTION file.
  If there is an existing "Suggests:" line, just add \texttt{scriptests}
  to it.  (It's better to use the \texttt{Suggests:} than the
  \texttt{Depends:} fields, because packages listed in the depends field
  are loaded when the package is loaded for normal use, and the
  \texttt{scriptests} package is usually not needed for normal use of a package --
  the \texttt{scriptests} package will only be needed for testing.

  At the end of testing, the file \texttt{test-summary.txt} will be left in
the \texttt{tests} directory.  To be entirely sure that the tests were
run, also check for the existence of \texttt{test-summary.txt}.

If any tests fail, the file \texttt{test-summary.fail} (a copy of
\texttt{test-summary.txt}) will also be left in the \texttt{tests} directory
-- the existence of this file can be used in a programmatic check for
whether all tests passed.

  Notes:
\begin{itemize}
    \item All commands in the transcript file must be prefixed with
    command or continuation prompts, exactly as they appear in a
    transcript.
    \item scriptests uses simple heuristics to identify commands, comments and
    output.  If the transcript cannot be separated into comments,
    commands and output by these heuristics (e.g., if a command prints
    out a line starting with the command prompt "> "), things will not
    work properly.
    \item When running tests in a package, scriptests uses a heuristic to
    guess the package name and automatically include an appropriate
    \texttt{library(package-being-tested)} command before the tests.  If
    this heuristic fails, the functions from the package being tested
    may not be accessible.  If this problem occurs, it can be worked
    around by explicitly including a
    \texttt{library(package-being-tested)} command at the beginning of
    each \texttt{.Rt} file.
    \item To have tests continue to run after encountering an error, put
    the command \texttt{options(error=function() NULL)} at the beginning
    of the transcript file.  This will cause the non-interactive R
    session that runs the commands in the scripts to continue after an
    error, instead of stopping, which is the default behavior for
    non-interactive R.
\end{itemize}

  \emph{Control over matching}

    Actual output is matched to desired output extracted from the
    transcript file in a line-by-line fashion.  If text is wrapped
    differently over multiple lines, the tests will fail (unless
    \texttt{ignore-linebreaks} is used). Different output width can easily
    happen if \texttt{options("width")} was different in the session that
    generated the desired output. Before trying to match, scriptests
    converts all white-space to single white-space, unless a control
    line specifies otherwise.

    The following control lines can be present in the transcript
    after a command and before its output:
    \begin{description}
      \item{#@ignore-output}{Ignore the output of this particular
        command -- a test with this control line will always pass
        (unless it causes an R error, and \texttt{options(error=function()
          NULL)} was not set.)}
      \item{#@gsub(pattern, replacement, WHAT)}{where \texttt{WHAT} is
        \texttt{target}, \texttt{actual} or \texttt{both} (without quotes).
        Make a global substitution of \texttt{replacement} text for
        \texttt{pattern} text (a regular expression) in the desired
        (target) output or the actual output.}  E.g.,
      \preformatted{
> cat("The date is <", date(), ">\n", sep="")
#@gsub("<[^>]*>", "<a date>", both)
The date is <Sat Jul 10 16:20:01 2010>
> }
      \item{#@warn-only: OPTIONAL-TEXT}{A mismatch is treated as an
        "warning", not an error}
      \item{#@info-only: OPTIONAL-TEXT}{A mismatch is treated as an
        "info" event, not an error}
      \item{#@diff-msg: OPTIONAL-TEXT}{Output OPTIONAL-TEXT if the
        desired and actual output do not match}
      \item{#@keep-whitespace}{Leave the whitespace as-is in the
        desired and actual output}
      \item{#@ignore-linebreaks}{Target and actual will match even
        if wrapped differently over multiple lines}
    \end{description}

The \texttt{tests} directory can also contain a CONFIG file, which can
specify the functions to call for testing.  The defaults are equivalent
to the following lines in the CONFIG file:
\begin{verbatim}
Depends: scriptests
Debug: FALSE
Initialize: scriptests:::initializeTests()
Diff: scriptests:::ScripDiff()
Finalize: scriptests:::summarizeTests() }
\end{verbatim}

The standard Emacs ESS functions for writing out \texttt{".Rt"} files will strip
trailing white space, which can result in many unimportant mismatches
when using \texttt{ediff} to compare \texttt{".Rt"} and \texttt{".Rout"} files (e.g.,
because an R transcript will have \texttt{"> "} for empty command lines).
Also, \texttt{".Rt"} files are read-only by default, and the return key is
bound to a command to send the current line to an R interpreter.  It is more
convenient if all these special behaviors are turned off.
Put the following in your \texttt{.emacs} file to tell ESS not mess with
\texttt{".Rt"} files prior to saving them:
\begin{verbatim}
(add-hook 'ess-transcript-mode-hook
          ;; According to the ess docs, ess-nuke-trailing-whitespace-p
          ;; is supposed to be nil by default (see the defvar in ess-utils.el).
          ;; But it gets set to t somewhere else, so disable it here for
          ;; .Rt files, and also make RET behave the regular way.
          (lambda ()
          (if (string-match ".[Rr]t$" (buffer-name))
             (progn
                (make-variable-buffer-local 'ess-nuke-trailing-whitespace-p)
                (define-key ess-transcript-mode-map (kbd "RET") 'newline)
                (toggle-read-only 0)
                (setq ess-nuke-trailing-whitespace-p nil)))) t)
\end{verbatim}

\end{document}
